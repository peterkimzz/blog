"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _createStarExport(obj) { Object.keys(obj) .filter((key) => key !== "default" && key !== "__esModule") .forEach((key) => { if (exports.hasOwnProperty(key)) { return; } Object.defineProperty(exports, key, {enumerable: true, configurable: true, get: () => obj[key]}); }); } function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } } function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }// src/index.ts
var _magicstringast = require('magic-string-ast'); _createStarExport(_magicstringast);
var _astkit = require('ast-kit'); _createStarExport(_astkit);

// src/ast.ts
var _compilersfc = require('@vue/compiler-sfc');

function checkInvalidScopeReference(node, method, setupBindings) {
  if (!node)
    return;
  _compilersfc.walkIdentifiers.call(void 0, node, (id) => {
    if (setupBindings.includes(id.name))
      throw new SyntaxError(
        `\`${method}()\` in <script setup> cannot reference locally declared variables (${id.name}) because it will be hoisted outside of the setup() function.`
      );
  });
}
function isStaticExpression(node, options = {}) {
  const { magicComment, fn, object, objectMethod, array, unary, regex } = options;
  if (magicComment && _optionalChain([node, 'access', _ => _.leadingComments, 'optionalAccess', _2 => _2.some, 'call', _3 => _3(
    (comment) => comment.value.trim() === magicComment
  )]))
    return true;
  else if (fn && _astkit.isFunctionType.call(void 0, node))
    return true;
  switch (node.type) {
    case "UnaryExpression":
      return !!unary && isStaticExpression(node.argument, options);
    case "LogicalExpression":
    case "BinaryExpression":
      return isStaticExpression(node.left, options) && isStaticExpression(node.right, options);
    case "ConditionalExpression":
      return isStaticExpression(node.test, options) && isStaticExpression(node.consequent, options) && isStaticExpression(node.alternate, options);
    case "SequenceExpression":
    case "TemplateLiteral":
      return node.expressions.every((expr) => isStaticExpression(expr, options));
    case "ArrayExpression":
      return !!array && node.elements.every(
        (element) => element && isStaticExpression(element, options)
      );
    case "ObjectExpression":
      return !!object && node.properties.every((prop) => {
        if (prop.type === "SpreadElement") {
          return prop.argument.type === "ObjectExpression" && isStaticExpression(prop.argument, options);
        } else if (!_astkit.isLiteralType.call(void 0, prop.key) && prop.computed) {
          return false;
        } else if (prop.type === "ObjectProperty" && !isStaticExpression(prop.value, options)) {
          return false;
        }
        if (prop.type === "ObjectMethod" && !objectMethod) {
          return false;
        }
        return true;
      });
    case "ParenthesizedExpression":
    case "TSNonNullExpression":
    case "TSAsExpression":
    case "TSTypeAssertion":
    case "TSSatisfiesExpression":
      return isStaticExpression(node.expression, options);
    case "RegExpLiteral":
      return !!regex;
  }
  if (_astkit.isLiteralType.call(void 0, node))
    return true;
  return false;
}
function isStaticObjectKey(node) {
  return node.properties.every((prop) => {
    if (prop.type === "SpreadElement") {
      return prop.argument.type === "ObjectExpression" && isStaticObjectKey(prop.argument);
    }
    return !prop.computed || _astkit.isLiteralType.call(void 0, prop.key);
  });
}
function resolveObjectExpression(node) {
  const maps = /* @__PURE__ */ Object.create(null);
  for (const property of node.properties) {
    if (property.type === "SpreadElement") {
      if (property.argument.type !== "ObjectExpression")
        return void 0;
      Object.assign(maps, resolveObjectExpression(property.argument));
    } else {
      const key = _astkit.resolveObjectKey.call(void 0, property);
      maps[key] = property;
    }
  }
  return maps;
}
var importedMap = /* @__PURE__ */ new WeakMap();
var HELPER_PREFIX = "__MACROS_";
function importHelperFn(s, offset, local, from = "vue", isDefault = false) {
  const imported = isDefault ? "default" : local;
  const cacheKey = `${from}@${imported}`;
  if (!_optionalChain([importedMap, 'access', _4 => _4.get, 'call', _5 => _5(s), 'optionalAccess', _6 => _6.has, 'call', _7 => _7(cacheKey)])) {
    s.appendLeft(
      offset,
      `
import ${isDefault ? HELPER_PREFIX + local : `{ ${imported} as ${HELPER_PREFIX + local} }`} from ${JSON.stringify(from)};`
    );
    if (!importedMap.has(s)) {
      importedMap.set(s, /* @__PURE__ */ new Set([cacheKey]));
    } else {
      importedMap.get(s).add(cacheKey);
    }
  }
  return `${HELPER_PREFIX}${local}`;
}

// src/constants.ts
var DEFINE_PROPS = "defineProps";
var DEFINE_PROPS_DOLLAR = "$defineProps";
var DEFINE_PROPS_REFS = "definePropsRefs";
var DEFINE_EMITS = "defineEmits";
var WITH_DEFAULTS = "withDefaults";
var DEFINE_OPTIONS = "defineOptions";
var DEFINE_MODELS = "defineModels";
var DEFINE_MODELS_DOLLAR = "$defineModels";
var DEFINE_SETUP_COMPONENT = "defineSetupComponent";
var DEFINE_RENDER = "defineRender";
var DEFINE_SLOTS = "defineSlots";
var DEFINE_PROP = "defineProp";
var DEFINE_EMIT = "defineEmit";
var REPO_ISSUE_URL = "https://github.com/vue-macros/vue-macros/issues";
var REGEX_SRC_FILE = /\.[cm]?[jt]sx?$/;
var REGEX_SETUP_SFC = /\.setup\.[cm]?[jt]sx?$/;
var REGEX_SETUP_SFC_SUB = /\.setup\.[cm]?[jt]sx?((?!vue&).)*$/;
var REGEX_VUE_SFC = /\.vue$/;
var REGEX_VUE_SUB = /\.vue\?vue&type=script/;
var REGEX_NODE_MODULES = /node_modules/;
var REGEX_SUPPORTED_EXT = /\.([cm]?[jt]sx?|vue)$/;
var VIRTUAL_ID_PREFIX = "/vue-macros";

// src/dep.ts
var _localpkg = require('local-pkg');
function detectVueVersion(root = process.cwd()) {
  const vuePkg = _localpkg.getPackageInfoSync.call(void 0, "vue", { paths: [root] });
  if (vuePkg && vuePkg.version) {
    const version = Number.parseFloat(vuePkg.version);
    return version >= 2 && version < 3 ? Math.trunc(version) : version;
  } else {
    return 3;
  }
}

// src/unplugin.ts


var _pluginutils = require('@rollup/pluginutils');


var getTransformResult = _magicstringast.generateTransform;
function createFilter(options) {
  return _pluginutils.createFilter.call(void 0, options.include, options.exclude);
}

// src/vue.ts




function parseSFC(code, id) {
  const sfc = _compilersfc.parse.call(void 0, code, {
    filename: id
  });
  const { descriptor, errors } = sfc;
  const scriptLang = _optionalChain([sfc, 'access', _8 => _8.descriptor, 'access', _9 => _9.script, 'optionalAccess', _10 => _10.lang]);
  const scriptSetupLang = _optionalChain([sfc, 'access', _11 => _11.descriptor, 'access', _12 => _12.scriptSetup, 'optionalAccess', _13 => _13.lang]);
  if (sfc.descriptor.script && sfc.descriptor.scriptSetup && (scriptLang || "js") !== (scriptSetupLang || "js")) {
    throw new Error(
      `[unplugin-vue-macros] <script> and <script setup> must have the same language type.`
    );
  }
  const lang = scriptLang || scriptSetupLang;
  return {
    sfc,
    ...descriptor,
    lang,
    errors,
    offset: _nullishCoalesce(_optionalChain([descriptor, 'access', _14 => _14.scriptSetup, 'optionalAccess', _15 => _15.loc, 'access', _16 => _16.start, 'access', _17 => _17.offset]), () => ( 0)),
    getSetupAst() {
      if (!descriptor.scriptSetup)
        return;
      return _astkit.babelParse.call(void 0, descriptor.scriptSetup.content, lang, {
        plugins: [["importAttributes", { deprecatedAssertSyntax: true }]]
      });
    },
    getScriptAst() {
      if (!descriptor.script)
        return;
      return _astkit.babelParse.call(void 0, descriptor.script.content, lang, {
        plugins: [["importAttributes", { deprecatedAssertSyntax: true }]]
      });
    }
  };
}
function getFileCodeAndLang(code, id) {
  if (!REGEX_VUE_SFC.test(id)) {
    return {
      code,
      lang: _astkit.getLang.call(void 0, id)
    };
  }
  const sfc = parseSFC(code, id);
  const scriptCode = _nullishCoalesce(_optionalChain([sfc, 'access', _18 => _18.script, 'optionalAccess', _19 => _19.content]), () => ( ""));
  return {
    code: sfc.scriptSetup ? `${scriptCode}
;
${sfc.scriptSetup.content}` : scriptCode,
    lang: _nullishCoalesce(sfc.lang, () => ( "js"))
  };
}
function addNormalScript({ script, lang }, s) {
  return {
    start() {
      if (script)
        return script.loc.end.offset;
      const attrs = lang ? ` lang="${lang}"` : "";
      s.prependLeft(0, `<script${attrs}>`);
      return 0;
    },
    end() {
      if (!script)
        s.appendRight(0, `
</script>
`);
    }
  };
}
function removeMacroImport(node, s, offset) {
  if (node.type === "ImportDeclaration" && _optionalChain([node, 'access', _20 => _20.attributes, 'optionalAccess', _21 => _21.some, 'call', _22 => _22(
    (attr) => _astkit.resolveString.call(void 0, attr.key) === "type" && attr.value.value === "macro"
  )])) {
    s.removeNode(node, { offset });
    return true;
  }
}





































exports.DEFINE_EMIT = DEFINE_EMIT; exports.DEFINE_EMITS = DEFINE_EMITS; exports.DEFINE_MODELS = DEFINE_MODELS; exports.DEFINE_MODELS_DOLLAR = DEFINE_MODELS_DOLLAR; exports.DEFINE_OPTIONS = DEFINE_OPTIONS; exports.DEFINE_PROP = DEFINE_PROP; exports.DEFINE_PROPS = DEFINE_PROPS; exports.DEFINE_PROPS_DOLLAR = DEFINE_PROPS_DOLLAR; exports.DEFINE_PROPS_REFS = DEFINE_PROPS_REFS; exports.DEFINE_RENDER = DEFINE_RENDER; exports.DEFINE_SETUP_COMPONENT = DEFINE_SETUP_COMPONENT; exports.DEFINE_SLOTS = DEFINE_SLOTS; exports.HELPER_PREFIX = HELPER_PREFIX; exports.REGEX_NODE_MODULES = REGEX_NODE_MODULES; exports.REGEX_SETUP_SFC = REGEX_SETUP_SFC; exports.REGEX_SETUP_SFC_SUB = REGEX_SETUP_SFC_SUB; exports.REGEX_SRC_FILE = REGEX_SRC_FILE; exports.REGEX_SUPPORTED_EXT = REGEX_SUPPORTED_EXT; exports.REGEX_VUE_SFC = REGEX_VUE_SFC; exports.REGEX_VUE_SUB = REGEX_VUE_SUB; exports.REPO_ISSUE_URL = REPO_ISSUE_URL; exports.VIRTUAL_ID_PREFIX = VIRTUAL_ID_PREFIX; exports.WITH_DEFAULTS = WITH_DEFAULTS; exports.addNormalScript = addNormalScript; exports.checkInvalidScopeReference = checkInvalidScopeReference; exports.createFilter = createFilter; exports.detectVueVersion = detectVueVersion; exports.getFileCodeAndLang = getFileCodeAndLang; exports.getTransformResult = getTransformResult; exports.importHelperFn = importHelperFn; exports.isStaticExpression = isStaticExpression; exports.isStaticObjectKey = isStaticObjectKey; exports.normalizePath = _pluginutils.normalizePath; exports.parseSFC = parseSFC; exports.removeMacroImport = removeMacroImport; exports.resolveObjectExpression = resolveObjectExpression;
