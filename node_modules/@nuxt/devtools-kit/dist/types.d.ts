import { V as VueInspectorData, a as VueInspectorClient, L as LoadingTimeMetric, H as HookInfo, P as PluginMetric, b as ServerFunctions } from './hooks-cf1b7911.js';
export { $ as AnalyzeBuildMeta, a0 as AnalyzeBuildsInfo, J as AssetInfo, F as AssetType, A as AutoImportsWithMetadata, B as BasicModuleInfo, C as CategorizedTabs, X as ClientFunctions, Y as ClientUpdateEvent, K as CodeSnippet, z as CompatibilityStatus, O as ComponentRelationship, U as GetWizardArgs, G as GitHubContributor, I as ImageMeta, _ as InstallModuleReturn, w as InstalledModuleInfo, E as MaintainerInfo, i as ModuleBuiltinTab, y as ModuleCompatibility, M as ModuleCustomTab, a2 as ModuleGlobalOptions, h as ModuleIframeTabLazyOptions, d as ModuleIframeView, f as ModuleLaunchAction, c as ModuleLaunchView, a1 as ModuleOptions, x as ModuleStaticInfo, j as ModuleTabInfo, D as ModuleType, e as ModuleVNodeView, g as ModuleView, q as NpmCommandOptions, p as NpmCommandType, a5 as NuxtDevToolsOptions, N as NuxtDevtoolsInfo, Z as NuxtDevtoolsServerContext, o as PackageManagerName, n as PackageUpdateInfo, u as Payload, v as PluginInfoWithMetic, R as RouteInfo, r as ServerRouteInfo, t as ServerRouteInput, s as ServerRouteInputType, S as SubprocessOptions, a6 as TabCategory, l as TerminalAction, k as TerminalBase, m as TerminalInfo, T as TerminalState, a3 as VSCodeIntegrationOptions, a4 as VSCodeTunnelOptions, Q as WizardActions, W as WizardFunctions } from './hooks-cf1b7911.js';
import { Ref } from 'vue';
import { AppConfig } from 'nuxt/schema';
import { NuxtApp } from 'nuxt/dist/app/nuxt';
import { Hookable } from 'hookable';
import { BirpcReturn } from 'birpc';
import { Lang } from 'shiki-es';
import { StackFrame } from 'error-stack-parser-es';
import 'nitropack';
import 'unstorage';
import 'vite-plugin-vue-inspector';
import 'unimport';
import 'vue-router';
import 'execa';
import '@nuxt/schema';

interface TimelineEventFunction {
    type: 'function';
    start: number;
    end?: number;
    name: string;
    args?: any[];
    result?: any;
    stacktrace?: StackFrame[];
    isPromise?: boolean;
}
interface TimelineEventRoute {
    type: 'route';
    start: number;
    end?: number;
    from: string;
    to: string;
}
interface TimelineOptions {
    enabled: boolean;
    stacktrace: boolean;
    arguments: boolean;
}
type TimelineEvent = TimelineEventFunction | TimelineEventRoute;
interface TimelineMetrics {
    events: TimelineEvent[];
    nonLiteralSymbol: symbol;
    options: TimelineOptions;
}
interface TimelineEventNormalized<T> {
    event: T;
    segment: TimelineEventsSegment;
    relativeStart: number;
    relativeWidth: number;
    layer: number;
}
interface TimelineEventsSegment {
    start: number;
    end: number;
    events: TimelineEvent[];
    functions: TimelineEventNormalized<TimelineEventFunction>[];
    route?: TimelineEventNormalized<TimelineEventRoute>;
    duration: number;
    previousGap?: number;
}

interface DevToolsFrameState {
    width: number;
    height: number;
    top: number;
    left: number;
    open: boolean;
    route: string;
    position: 'left' | 'right' | 'bottom' | 'top';
    closeOnOutsideClick: boolean;
    minimizePanelInactive: number;
}
interface NuxtDevtoolsClientHooks {
    /**
     * When the DevTools navigates, used for persisting the current tab
     */
    'devtools:navigate': (path: string) => void;
    /**
     * Event emitted when the component inspector is updated
     */
    'host:inspector:update': (data: VueInspectorData) => void;
    /**
     * Event emitted when the component inspector is clicked
     */
    'host:inspector:click': (baseUrl: string, file: string, line: number, column: number) => void;
    /**
     * Event to close the component inspector
     */
    'host:inspector:close': () => void;
    /**
     * Triggers reactivity manually, since Vue won't be reactive across frames)
     */
    'host:update:reactivity': () => void;
}
/**
 * Host client from the App
 */
interface NuxtDevtoolsHostClient {
    nuxt: NuxtApp;
    appConfig: AppConfig;
    hooks: Hookable<NuxtDevtoolsClientHooks>;
    colorMode: Ref<'dark' | 'light'>;
    inspector?: {
        instance?: VueInspectorClient;
        enable: () => void;
        disable: () => void;
        toggle: () => void;
        isEnabled: Ref<boolean>;
    };
    loadingTimeMetrics: LoadingTimeMetric;
    getClientHooksMetrics(): HookInfo[];
    clientPluginMetrics: PluginMetric[] | undefined;
    clientTimelineMetrics: TimelineMetrics | undefined;
    reloadPage(): void;
    close(): void;
    open(): void;
    toggle(): void;
    /**
     * Popup the DevTools frame into Picture-in-Picture mode
     *
     * Requires Chrome 111 with experimental flag enabled.
     *
     * Function is undefined when not supported.
     *
     * @see https://developer.chrome.com/docs/web-platform/document-picture-in-picture/
     */
    popup?(): any;
    /**
     * Update client
     * @internal
     */
    updateClient(): NuxtDevtoolsHostClient;
    getIframe(): HTMLIFrameElement | undefined;
    frameState: Ref<DevToolsFrameState>;
}
interface NuxtDevtoolsClient {
    rpc: BirpcReturn<ServerFunctions>;
    renderCodeHighlight: (code: string, lang?: Lang) => {
        code: string;
        supported: boolean;
    };
    renderMarkdown: (markdown: string) => string;
    colorMode: string;
    extendClientRpc: <ServerFunctions = Record<string, never>, ClientFunctions = Record<string, never>>(name: string, functions: ClientFunctions) => BirpcReturn<ServerFunctions, ClientFunctions>;
}
interface NuxtDevtoolsIframeClient {
    host: NuxtDevtoolsHostClient;
    devtools: NuxtDevtoolsClient;
}
interface NuxtDevtoolsGlobal {
    setClient(client: NuxtDevtoolsHostClient): void;
}

export { DevToolsFrameState, HookInfo, LoadingTimeMetric, NuxtDevtoolsClient, NuxtDevtoolsClientHooks, NuxtDevtoolsGlobal, NuxtDevtoolsHostClient, NuxtDevtoolsIframeClient, PluginMetric, ServerFunctions, TimelineEvent, TimelineEventFunction, TimelineEventNormalized, TimelineEventRoute, TimelineEventsSegment, TimelineMetrics, TimelineOptions, VueInspectorClient, VueInspectorData };
